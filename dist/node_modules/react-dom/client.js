(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

    const FunctionComponent = 0;
    // 项目挂载的根节点
    // 011
    const HostRoot = 3;
    // <div>
    // 0101
    const HostComponent = 5;
    // 文本节点
    // 0110
    const HostText = 6;

    // 使用2进制来保存
    const NoFlags = 0b0000000;
    const Placement = 0b0000001;
    const Update = 0b0000010;
    const ChildDeletion = 0b0000100;
    // 代表了mutation阶段需要执行的操作
    const MutationMask = Placement | Update | ChildDeletion;

    /**
     * @tag 表示FiberNode是什么类型的节点
     */
    class FiberNode {
        type;
        tag;
        pendingProps;
        key;
        stateNode;
        ref;
        return;
        sibling;
        child;
        index;
        memoizedProps;
        memoizedState;
        // 用于FiberNode和另外一个FiberNode之间切换
        alternate;
        // 保存操作标记
        flags;
        // 代表子树中包含的flags
        subtreeFlags;
        updateQueue;
        constructor(tag, pendingProps, key) {
            // 实例
            this.tag = tag;
            this.key = key;
            // stateNode比如对于HostComponent来说 <div> div DOM
            this.stateNode = null;
            // 对于FunctionComponent来说 type是 () => {}
            this.type = null;
            // 除了作为一个实例还有一个字段来表示节点关系
            // 构成树状结构
            // 指向父fiberNode
            this.return = null;
            // 指向兄弟fiberNode
            this.sibling = null;
            // 指向子fiberNode
            this.child = null;
            // <ul><li></li></ul>
            this.index = 0;
            this.ref = null;
            // 作为工作单元
            // 刚开始工作的时候的props是什么
            this.pendingProps = pendingProps;
            // 工作完之后的props是什么,也就是确定下来的props是什么
            this.memoizedProps = null;
            this.memoizedState = null;
            this.alternate = null;
            this.updateQueue = null;
            // 副作用
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
        }
    }
    // 实现根节点fiberRootNode
    class fiberRootNode {
        // 宿主环境的dom挂载的节点
        // 但是我们不能直接定义为rootElement，因为对于其他环境就不是Element,我们需要一个更加抽象的名字
        container;
        // 这个指向hostRootFiber
        current;
        // 这个指向我们更新完成以后的hostRootFiber
        finishedWork;
        constructor(container, hostRootFiber) {
            this.container = container;
            this.current = hostRootFiber;
            hostRootFiber.stateNode = this;
            this.finishedWork = null;
        }
    }
    // current也就是hostRootFiber
    // 这里用到了双缓存技术，
    const createWorkInProgress = (current, pendingProps) => {
        let wip = current.alternate;
        if (wip === null) {
            // 对于首屏渲染wip就是null
            // mount
            wip = new FiberNode(current.tag, pendingProps, current.key);
            wip.type = current.type;
            wip.stateNode = current.stateNode;
            wip.alternate = current;
            current.alternate = wip;
        }
        else {
            // update
            wip.pendingProps = pendingProps;
            // 将副作用东西全部清除
            wip.flags = NoFlags;
            wip.subtreeFlags = NoFlags;
        }
        wip.type = current.type;
        wip.updateQueue = current.updateQueue;
        wip.child = current.child;
        wip.memoizedProps = current.memoizedProps;
        wip.memoizedState = current.memoizedState;
        return wip;
    };
    // 根据element创建fiber
    function createFiberFromElement(element) {
        const { type, key, props } = element;
        // 根据不同的type来返回不同的FiberNode
        let fiberTag = FunctionComponent;
        if (typeof type === 'string') {
            // <div> type 'div'
            fiberTag = HostComponent;
        }
        else if (typeof type !== 'function' && true) {
            console.warn('未定义的type类型', element);
        }
        const fiber = new FiberNode(fiberTag, props, key);
        fiber.type = type;
        return fiber;
    }

    // 实现创建update实例的方法createUpdate
    const createUpdate = (action) => {
        // 返回update的实例
        return {
            action
        };
    };
    // 实现创建UpdateQueue实例的方法
    // UpdateQueue是一个保存Update的数据结构
    const createUpdateQueue = () => {
        return {
            shared: {
                pending: null
            }
        };
    };
    // 往UpdateQueue里增加Update
    const enqueueUpdate = (updateQueue, update) => {
        updateQueue.shared.pending = update;
    };
    // enqueueUpdate消费Updated的方法
    // 接收一个初始的状态baseState以及要消费的UpdatependingUpdate
    // 返回值是全新的状态memoizeState
    const processUpdateQueue = (baseState, pendingUpdate) => {
        // ReturnType是获取函数放回值的类型
        const result = {
            memoizedState: baseState
        };
        if (pendingUpdate !== null) {
            // baseState 1 update (x) => 4x -> memoizedState 4
            const action = pendingUpdate?.action;
            if (action instanceof Function) {
                result.memoizedState = action(baseState);
            }
            else {
                // baseState 1 update 2 -> memoizedState 2
                result.memoizedState = action;
            }
        }
        return result;
    };

    // Symbol是否存在
    const supportSymbol = typeof Symbol === 'function' && Symbol.for;
    const REACT_ELEMENT_TYPE = supportSymbol ? Symbol.for('react.element') : 0xeac7;

    // 实现生成子节点以及标记Fibers的过程
    // shouldTrackEffects是否应该追踪副作用false代表不需要
    function ChildReconciler(shouldTrackEffects) {
        // 通过ReactElementType生成新的FiberNode并建立父子的FiberNode的关系
        function reconcileSingleElement(returnFiber, currentFiber, element) {
            // 根据element创建Fiber
            const fiber = createFiberFromElement(element);
            // 将创建的fiber父节点指向returnFiber
            fiber.return = returnFiber;
            return fiber;
        }
        function reconcileSingleTextNode(returnFiber, currentFiber, content) {
            const fiber = new FiberNode(HostText, { content }, null);
            fiber.return = returnFiber;
            return fiber;
        }
        // 插入单一的节点(性能优化)
        // 打上标记
        function placeSingleChild(fiber) {
            // 在首屏渲染的情况下
            if (shouldTrackEffects && fiber.alternate === null) {
                // 按位或操作
                fiber.flags |= Placement;
            }
            return fiber;
        }
        return function reconcileChildFibers(
        // 父节点的FiberNode
        returnFiber, 
        // 当前节点的子节点的FiberNode
        currentFiber, 
        // 子节点的ReactElement
        newChild) {
            // 判断当前fiber的类型
            if (typeof newChild === 'object' && newChild !== null) {
                switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                        // 根据newChild生成一个新的FiberNode并且指向returnFiber，如果是首次渲染的话会直接给flags加上Placement标记
                        // 最终返回新的FiberNode
                        return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                    default:
                        {
                            console.warn('未实现的reconcile类型', newChild);
                        }
                        break;
                }
            }
            // 多节点的情况 ul > 3li
            // HostText
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
            }
            // 如果以上都没有
            {
                console.warn('未实现的reconcile类型', newChild);
            }
            return null;
        };
    }
    // 更新
    const reconcileChildFibers = ChildReconciler(true);
    // 挂载
    const mountChildFibers = ChildReconciler(false);

    function renderWithHooks(wip) {
        // 如果传入的是一个函数组件，那么FiberNode的type就是方法图
        const Component = wip.type;
        const props = wip.pendingProps;
        // 函数返回的就是children
        const children = Component(props);
        return children;
    }

    // 递归中的递阶段
    // beginWork的工作流程
    // 1.计算状态的最新值
    // 2.创造子fiberNode
    const beginWork = (wip) => {
        // 比较，返回子fiberNode
        switch (wip.tag) {
            case HostRoot:
                return updateHostRoot(wip);
            case HostComponent:
                return updateHostComponent(wip);
            case HostText:
                return null;
            case FunctionComponent:
                return updateFunctionComponent(wip);
            default:
                {
                    console.warn('beginWork未实现的类型');
                }
                break;
        }
        return null;
    };
    function updateFunctionComponent(wip) {
        // 这里也是拿到子节点然然调用reconileChildren
        const nextChildren = renderWithHooks(wip);
        reconileChildren(wip, nextChildren);
        return wip.child;
    }
    function updateHostRoot(wip) {
        const baseState = wip.memoizedState;
        const updateQueue = wip.updateQueue;
        // 取出的pending就是Update对象
        // Update的对象里面包含action，action的值是传进来的ReactElementType对象
        const pending = updateQueue.shared.pending;
        // 清空原有对象中的pending
        updateQueue.shared.pending = null;
        const { memoizedState } = processUpdateQueue(baseState, pending);
        // 从目前上看这里是拿到了ReactElementType对象并且保存到memoizedState
        wip.memoizedState = memoizedState;
        // 这是更新后的ReactElementType
        const nextChildren = wip.memoizedState;
        // 比较子节点赋值回新的child
        reconileChildren(wip, nextChildren);
        // 返回子节点
        return wip.child;
    }
    function updateHostComponent(wip) {
        const nextProps = wip.pendingProps;
        const nextChildren = nextProps.children;
        reconileChildren(wip, nextChildren);
        return wip.child;
    }
    // 这个方法整体就是传入FiberNode以及当前子节点的ReactElementType
    // 然后比较FiberNode子节点与ReactElementType生成新的子节点FiberNode
    function reconileChildren(wip, children) {
        // 目前只有HostRootFiber是有alternate的
        const current = wip.alternate;
        if (current !== null) {
            // update
            // 比较子节点的current与子节点的ReactElementType
            // wip是当前的FiberNode父节点, current.child是上一个FiberNode子节点, children是当前的ReactElementType子节点
            // 目前的方法是根据children直接生成新的FiberNode,并将return指向wip,并加上flags标记
            wip.child = reconcileChildFibers(wip, current?.child, children);
        }
        else {
            // mount
            wip.child = mountChildFibers(wip, null, children);
        }
    }

    // 暂时先把props去掉
    const createInstance = (type, props) => {
        // TODO 处理props
        const element = document.createElement(type);
        return element;
    };
    const appendInitialChild = (parent, child) => {
        parent.appendChild(child);
    };
    const createTextInstance = (content) => {
        return document.createTextNode(content);
    };
    const appendChildToContainer = appendInitialChild;

    let nextEffect = null;
    const commitMutationEffects = (finishedWork) => {
        nextEffect = finishedWork;
        while (nextEffect !== null) {
            // 向下遍历
            const child = nextEffect.child;
            // 这里这么做的原因，是找到最下级的需要操作的子节点，从当前子节点开始往上遍历之后再调用commitMutationEffectsOnFiber开始每个操作
            if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
                // 若存在子节点需要更新的操作则向下继续遍历
                nextEffect = child;
            }
            else {
                // 证明要找的子节点不包含subtreeFlags
                // 向上遍历DFS
                while (nextEffect !== null) {
                    commitMutationEffectsOnFiber(nextEffect);
                    // 兄弟节点
                    const sibling = nextEffect.sibling;
                    if (sibling !== null) {
                        nextEffect = sibling;
                        break;
                    }
                    nextEffect = nextEffect.return;
                }
            }
        }
    };
    const commitMutationEffectsOnFiber = (finishedWork) => {
        const flags = finishedWork.flags;
        if ((flags & Placement) !== NoFlags) {
            // 执行Placement操作
            commitPlacement(finishedWork);
            // 这个相当于删除的操作
            finishedWork.flags &= ~Placement;
        }
    };
    const commitPlacement = (finishedWork) => {
        {
            console.warn('执行Placement操作', finishedWork);
        }
        // parent DOM
        // 这里是拿到当前的fiberNode的父节点
        const hostParent = getHostParent(finishedWork);
        console.log('finishedWork', finishedWork);
        console.log('hostParent', hostParent);
        // 接下来找到finishedWork对应的DOM并且将DOM append 到 parentDOM中
        if (hostParent !== null) {
            appendPlacementNodeIntoContainer(finishedWork, hostParent);
        }
    };
    // 获得父级的宿主环境的节点
    function getHostParent(fiber) {
        // 执行一个向上遍历的过程
        let parent = fiber.return;
        while (parent) {
            const parentTag = parent.tag;
            // 那种环境下parentTag才对呀的是宿主环境下的父级节点呢
            // HostComponent HostRoot
            if (parentTag === HostComponent) {
                return parent.stateNode;
            }
            if (parentTag === HostRoot) {
                return parent.stateNode.container;
            }
            parent = parent.return;
            {
                console.warn('未找到host: parent');
            }
        }
        return null;
    }
    function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
        // 向下遍历
        if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
            // 这里是将FiberNode的stateNode给插入到父级的DOM中，其实部分元素在completeWork已经插入，再调用一次的话等于将原来的DOM再插入一次，不会有任何变化，但貌似没有性能优化，这是一个没必要的操作
            // 只有在最后的当finishedWork = HostRootFiber的时候此时容器hostParent拿到的是挂载的节点#root这个时候就会挂载到界面上
            appendChildToContainer(hostParent, finishedWork.stateNode);
            return;
        }
        const child = finishedWork.child;
        if (child !== null) {
            appendPlacementNodeIntoContainer(child, hostParent);
            let sibling = child.sibling;
            while (sibling !== null) {
                appendPlacementNodeIntoContainer(sibling, hostParent);
                sibling = sibling.sibling;
            }
        }
    }

    const completeWork = (wip) => {
        // 递归中的归
        const newProps = wip.pendingProps;
        const current = wip.alternate;
        switch (wip.tag) {
            case HostComponent:
                if (current !== null && wip.stateNode) ;
                else {
                    // 1.构建真实DOM
                    const instance = createInstance(wip.type);
                    // 2.将DOM插入到DOM树中
                    appendAllChildren(instance, wip);
                    wip.stateNode = instance;
                }
                // flags冒泡
                bubbleProperties(wip);
                return null;
            case HostText:
                if (current !== null && wip.stateNode) ;
                else {
                    // 1.构建DOM
                    const instance = createTextInstance(newProps.content);
                    wip.stateNode = instance;
                }
                // flags冒泡
                bubbleProperties(wip);
                return null;
            case HostRoot:
                // flags冒泡
                bubbleProperties(wip);
                return null;
            case FunctionComponent:
                // flags冒泡
                bubbleProperties(wip);
                return null;
            default:
                {
                    console.warn('未处理的completeWork情况', wip);
                }
                break;
        }
    };
    // 接收一个parent以及要插入的FiberNode wip
    function appendAllChildren(parent, wip) {
        let node = wip.child;
        while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node?.stateNode);
            }
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === wip) {
                return;
            }
            while (node.sibling === null) {
                if (node.return === null || node.return === wip) {
                    return;
                }
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    // 向上冒泡
    // completeWork是向上遍历的过程，所以拿到的节点一定是当前最顶部的节点，而咋子beginWork的过程中我们标记了flags
    // 我们为了不让更新时候再次产生整个树的深层递归，定义了一个subtreeFage标记了当前DOM树中子节点是否存在需要操作的标记
    function bubbleProperties(wip) {
        let subtreeFlags = NoFlags;
        let child = wip.child;
        while (child !== null) {
            subtreeFlags |= child.subtreeFlags;
            subtreeFlags |= child.flags;
            child.return = wip;
            child = child.sibling;
        }
        wip.subtreeFlags |= subtreeFlags;
    }

    // 这个是完整的工作循环的文件
    // 我们这里需要一个全局的指针来指向当前工作的FiberNode
    let workInProgress = null;
    // 初始化workInProgress
    function prepareFreshStack(root) {
        // root.current也就是hostRootFiber
        // workInProgress：触发更新后，正在reconciler中计算的fiberNode树
        // createWorkInProgress的作用是传入一个hostRootFiber（也是FiberNode类型）然后返回一个新的hostRootFiber,并将旧的信息保存到hostRootFiber.alternate里面
        // 保存到workInProgress中
        workInProgress = createWorkInProgress(root.current, {});
    }
    // 连接Container以及renderRoot的方法
    // 在Fiber调度Update
    function scheduleUpdateOnFiber(fiber) {
        // TODO 调度功能
        // 拿到根节点fiberRootNode
        const root = markUpdateFromFiberToRoot(fiber);
        // 调用renderRoot开始跟新
        renderRoot(root);
    }
    // 向上遍历拿到fiberRootNode
    function markUpdateFromFiberToRoot(fiber) {
        let node = fiber;
        let parent = node.return;
        while (parent !== null) {
            node = parent;
            parent = node.return;
        }
        if (node.tag === HostRoot) {
            return node.stateNode;
        }
        return null;
    }
    // 从跟节点开始更新
    function renderRoot(root) {
        // 初始化
        prepareFreshStack(root);
        // 执行递归流程
        do {
            try {
                workLoop();
                // 没有问题这里会直接跳出,到这个阶段的workInProgress已经遍历完，workInProgress会指向null
                break;
            }
            catch (e) {
                {
                    console.warn('workLoop发生错误');
                }
                // 改变指针
                workInProgress = null;
            }
        } while (true);
        // root.current.alternate就是workInProgress最开始指向的根节点
        // 这个时候的root.current.alternate已经是调度完成了，所以finishedWork会有最新的stateNode，也会有需要更新的flags标记
        const finishedWork = root.current.alternate;
        // 保存到finishedWork
        root.finishedWork = finishedWork;
        // 这里就可以根据fiberNode树 书中的flags
        commitRoot(root);
    }
    function commitRoot(root) {
        const finishedWork = root.finishedWork;
        if (finishedWork === null) {
            return;
        }
        {
            console.warn('commit阶段开始', finishedWork);
        }
        // 重置
        root.finishedWork = null;
        // 判断是否存在3个子阶段需要执行得到操作
        // 需要判断root本身的flags以及root的subtreeFlags
        // 这里是按位与操作subtreeHasEffect !== NoFlags标识存在子节点需要更新操作
        const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
        // rootHasEffect标识根节点存在需要更新的操作
        const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
        if (subtreeHasEffect || rootHasEffect) {
            // beforeMutation
            // mutation Placement
            commitMutationEffects(finishedWork);
            root.current = finishedWork;
            // layout
        }
        else {
            root.current = finishedWork;
        }
    }
    function workLoop() {
        // 只要指针不等于null就能一直循环下去,这里也就是递归中的递
        // 但completeUnitOfWork中循环到最上层的时候workInProgress则为null就会中断这一层方法内的while循环
        while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
        }
    }
    function performUnitOfWork(fiber) {
        // beginWork会拿到下一层得到子FiberNode
        const next = beginWork(fiber);
        fiber.memoizedProps = fiber.pendingProps;
        // 判断是否有下一层的FiberNode
        if (next === null) {
            console.log('workInProgress', workInProgress);
            // 不存在调用归
            completeUnitOfWork(fiber);
        }
        else {
            // 存在则指针指向下一层
            workInProgress = next;
        }
    }
    function completeUnitOfWork(fiber) {
        let node = fiber;
        do {
            // 执行递归中的归
            completeWork(node);
            // 拿到兄弟节点
            const sibling = node.sibling;
            if (sibling) {
                // 如果兄弟节点存在则指针指向兄弟节点
                workInProgress = sibling;
                return;
            }
            // 如果兄弟节点不存在则拿父级节点
            node = node.return;
            // 改变指针指向父级
            workInProgress = node;
        } while (node !== null);
    }

    // 实现mount时调用的api
    function createContainer(container) {
        const hostRootFiber = new FiberNode(HostRoot, {}, null);
        const root = new fiberRootNode(container, hostRootFiber);
        hostRootFiber.updateQueue = createUpdateQueue();
        return root;
    }
    // 执行render方法后内部调用的api
    function updateContainer(element, root) {
        const hostRootFiber = root.current;
        // 创建一个新的额Update
        // element也就是render传进来的ReactElementType
        const update = createUpdate(element);
        // UpdateQueue是保存Update的数据结构
        // enqueueUpdate是将Update保存进UpdateQueue
        // 这里会将{ action: ReactElementType }结构数据保存金hostRootFiber.updateQueue.shared.padding里面
        enqueueUpdate(hostRootFiber.updateQueue, update);
        // 然后执行调度
        scheduleUpdateOnFiber(hostRootFiber);
        return element;
    }

    // ReactDOM.createRoot(root).render(<APP/>)
    function createRoot(container) {
        // 创建容器container其实就是挂载的dom节点
        const root = createContainer(container);
        console.log(root);
        return {
            render(element) {
                updateContainer(element, root);
            }
        };
    }

    var ReactDOM = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createRoot: createRoot
    });

    return ReactDOM;

}));
