(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('scheduler')) :
    typeof define === 'function' && define.amd ? define(['react', 'scheduler'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory(global.React, global.scheduler));
})(this, (function (React, scheduler) { 'use strict';

    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }

    var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

    const FunctionComponent = 0;
    // 项目挂载的根节点
    // 011
    const HostRoot = 3;
    // <div>
    // 0101
    const HostComponent = 5;
    // 文本节点
    // 0110
    const HostText = 6;
    const Fragment = 7;

    // 使用2进制来保存
    const NoFlags = 0b0000000;
    const Placement = 0b0000001;
    const Update = 0b0000010;
    const ChildDeletion = 0b0000100;
    // 代表当前fiber上本次更新存在需要触发UseEffect的情况
    // 对于fiber, 新增PassiveEffect,代表[当前fiber本次更新存在副作用]
    // 至于本次更新存在哪一种副作用需要通过hookEffectTags下的tag来决定
    const PassiveEffect = 0b0001000;
    // 代表了mutation阶段需要执行的操作
    const MutationMask = Placement | Update | ChildDeletion;
    const PassiveMask = PassiveEffect | ChildDeletion;

    // lane 可以作为update的优先级
    // 同步优先级
    const SyncLane = 0b0001;
    const NoLane = 0b0000;
    const NoLanes = 0b000;
    function mergeLanes(laneA, laneB) {
        return laneA | laneB;
    }
    function requestUpdateLane() {
        return SyncLane;
    }
    // 返回优先级最高的Lane
    function getHighesPriorityLane(lanes) {
        // 数字越小优先级越高
        // 返回数字越小的的哪一个
        return lanes & -lanes;
    }
    function markRootFinished(root, lane) {
        // 移除
        root.pendingLanes &= ~lane;
    }

    /**
     * @tag 表示FiberNode是什么类型的节点
     */
    class FiberNode {
        // 这个就是ReactElementType的type值，当为组件的时候type就是方法体，如果为普通节点type就是'div'之类的字符串，跟vue的h函数的第一个参数一个概念
        type;
        // 这里也是也是区分不同节点类型的一个地方,在根据ReactElementType创建FiberNode的时候有做判断，唯独多了一个HostRoot的类型，是ReactElementType没有的
        tag;
        pendingProps;
        key;
        stateNode;
        ref;
        return;
        sibling;
        child;
        index;
        memoizedProps;
        memoizedState;
        // 用于FiberNode和另外一个FiberNode之间切换
        alternate;
        // 保存操作标记
        flags;
        // 代表子树中包含的flags
        subtreeFlags;
        updateQueue;
        deletions;
        constructor(tag, pendingProps, key) {
            // 实例
            this.tag = tag;
            this.key = key || null;
            // stateNode比如对于HostComponent来说 <div> div DOM
            this.stateNode = null;
            // 对于FunctionComponent来说 type是 () => {}
            this.type = null;
            // 除了作为一个实例还有一个字段来表示节点关系
            // 构成树状结构
            // 指向父fiberNode
            this.return = null;
            // 指向兄弟fiberNode
            this.sibling = null;
            // 指向子fiberNode
            this.child = null;
            // <ul><li></li></ul>
            this.index = 0;
            this.ref = null;
            // 作为工作单元
            // 刚开始工作的时候的props是什么
            this.pendingProps = pendingProps;
            // 工作完之后的props是什么,也就是确定下来的props是什么
            this.memoizedProps = null;
            this.memoizedState = null;
            this.alternate = null;
            this.updateQueue = null;
            // 副作用
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
        }
    }
    // 实现根节点fiberRootNode
    class fiberRootNode {
        // 宿主环境的dom挂载的节点
        // 但是我们不能直接定义为rootElement，因为对于其他环境就不是Element,我们需要一个更加抽象的名字
        container;
        // 这个指向hostRootFiber
        current;
        // 这个指向我们更新完成以后的hostRootFiber
        finishedWork;
        // 代表所有没有被消费的Lane的集合
        pendingLanes;
        // 本次更新消费的Lane
        finishedLane;
        pendingPassiveEffects;
        constructor(container, hostRootFiber) {
            this.container = container;
            this.current = hostRootFiber;
            hostRootFiber.stateNode = this;
            this.finishedWork = null;
            this.finishedLane = NoLanes;
            this.pendingLanes = NoLane;
            this.pendingPassiveEffects = {
                unmount: [],
                update: []
            };
        }
    }
    // current也就是hostRootFiber
    // 这里用到了双缓存技术，
    const createWorkInProgress = (current, pendingProps) => {
        let wip = current.alternate;
        if (wip === null) {
            // 对于首屏渲染wip就是null
            // mount
            wip = new FiberNode(current.tag, pendingProps, current.key);
            wip.type = current.type;
            wip.stateNode = current.stateNode;
            wip.alternate = current;
            current.alternate = wip;
        }
        else {
            // update
            wip.pendingProps = pendingProps;
            // 将副作用东西全部清除
            wip.flags = NoFlags;
            wip.subtreeFlags = NoFlags;
            wip.deletions = null;
        }
        wip.type = current.type;
        wip.updateQueue = current.updateQueue;
        wip.child = current.child;
        wip.memoizedProps = current.memoizedProps;
        wip.memoizedState = current.memoizedState;
        return wip;
    };
    // 根据element创建fiber
    function createFiberFromElement(element) {
        const { type, key, props } = element;
        // 根据不同的type来返回不同的FiberNode
        let fiberTag = FunctionComponent;
        if (typeof type === 'string') {
            // <div> type 'div'
            fiberTag = HostComponent;
        }
        else if (typeof type !== 'function' && true) {
            console.warn('未定义的type类型', element);
        }
        const fiber = new FiberNode(fiberTag, props, key);
        fiber.type = type;
        return fiber;
    }
    function createFiberFromFragment(elements, key) {
        const fiber = new FiberNode(Fragment, elements, key);
        return fiber;
    }

    // 实现创建update实例的方法createUpdate
    const createUpdate = (action, lane) => {
        // 返回update的实例
        return {
            action,
            lane,
            next: null
        };
    };
    // 实现创建UpdateQueue实例的方法
    // UpdateQueue是一个保存Update的数据结构
    const createUpdateQueue = () => {
        return {
            shared: {
                pending: null
            },
            dispatch: null
        };
    };
    // 往UpdateQueue里增加Update
    const enqueueUpdate = (updateQueue, update) => {
        const pending = updateQueue.shared.pending;
        // 这里会形成一个环状链表
        if (pending === null) {
            // a -> a
            update.next = update;
        }
        else {
            // pending = b -> a -> b
            // pending = c -> a -> b -> c
            update.next = pending.next;
            pending.next = update;
        }
        updateQueue.shared.pending = update;
    };
    // enqueueUpdate消费Update的方法
    // 接收一个初始的状态baseState以及要消费的Update pendingUpdate
    // 返回值是全新的状态memoizeState
    // Update为一个链表.next就是下一个Update
    const processUpdateQueue = (baseState, pendingUpdate, renderLane) => {
        // ReturnType是获取函数放回值的类型
        const result = {
            memoizedState: baseState
        };
        if (pendingUpdate !== null) {
            // 第一个update,因为是环状链表
            const first = pendingUpdate.next;
            let pending = pendingUpdate.next;
            // pending !== first循环一圈刚好就是遍历了一整条链表
            do {
                // 获取当前Update的优先级
                const updateLane = pending.lane;
                // 判断当前消费的优先级是否相等
                if (updateLane === renderLane) {
                    // 去除update的action循环更新得出最新的baseState
                    // baseState 1 update (x) => 4x -> memoizedState 4
                    const action = pendingUpdate?.action;
                    if (action instanceof Function) {
                        baseState = action(baseState);
                    }
                    else {
                        // baseState 1 update 2 -> memoizedState 2
                        baseState = action;
                    }
                }
                else {
                    {
                        console.error('不应该进入updateLane !== renderLane这个逻辑');
                    }
                }
                pending = pending?.next;
            } while (pending !== first);
        }
        // 从新赋值回给memoizedState
        result.memoizedState = baseState;
        return result;
    };

    // 对于一个dom需要在某个属性上对于的element的props
    const elementPropsKey = '__props';
    function updateFiberProps(node, props) {
        node[elementPropsKey] = props;
    }
    const validEventTypeList = ['click'];
    // 初始化事件,这里的container接收的是root的容器
    function initEvent(container, eventType) {
        if (!validEventTypeList.includes(eventType)) {
            console.warn('当前不支持', eventType, '事件');
        }
        {
            console.log('初始化事件', eventType);
        }
        container.addEventListener(eventType, (e) => {
            // 当触发事件的时候
            dispatchEvent(container, eventType, e);
        });
    }
    /**
     * 构造合成事件
     * @param e 实际触发时间段额event对象
     * @returns
     */
    function createSyntheticEvent(e) {
        // 这个作为合成事件的对象
        const syntheticEvent = e;
        // 定义一个默认值,这个是是否阻止冒泡的标记。默认false为不阻止
        syntheticEvent.__stopPropagation = false;
        // e.stopPropagation 这个是阻止事件冒泡的方法
        const originStopPropagation = e.stopPropagation;
        // 为合成事件对象添加多一个阻止事件冒泡的方法
        syntheticEvent.stopPropagation = () => {
            // 内部调用原来的e.stopPropagation，多做的一步操作是将__stopPropagation标记为true
            syntheticEvent.__stopPropagation = true;
            if (originStopPropagation) {
                // 执行原始的主治冒泡的方法
                originStopPropagation();
            }
        };
        // 将对象返回
        return syntheticEvent;
    }
    /**
     * 这里是实际事件触发的地方
     * @param container 容器
     * @param eventType 事件类型
     * @param e event对象
     * @returns
     */
    function dispatchEvent(container, eventType, e) {
        // 这里是触发事件的实际的target,也就是真正触发事件的目标对象
        const targetElement = e.target;
        if (targetElement === null) {
            console.warn('事件不存在target', e);
            return;
        }
        // 1.收集沿途的事件，意思就是从当前点击的节点到react的root中如果有注册过onClick事件都会被收集
        const { bubble, capture } = collectPaths(targetElement, container, eventType);
        // 2.构造合成事件，se就是e的事件合成对象，目前是多了一个阻止冒泡的方法
        const se = createSyntheticEvent(e);
        // 3.遍历触发captue里面的事件
        triggerEventFlow(capture, se);
        if (!se.__stopPropagation) {
            // 4.遍历bubble
            triggerEventFlow(bubble, se);
        }
    }
    /**
     * 时间数组的遍历方法
     * @param paths 遍历的数组
     * @param se 事件合成对象
     */
    function triggerEventFlow(paths, se) {
        for (let i = 0; i < paths.length; i++) {
            // 这里会将事件一个个循环调用
            const callback = paths[i];
            // 这里真正执行注册事件回调的地方，如果此时的se调用了阻止事件冒泡，那么下面的__stopPropagation就会是false
            callback.call(null, se);
            // 如果有调用过注释冒泡的方法时候那么，时间数组后面就会终止调用，这样就起到了阻止事件冒泡的效果
            if (se.__stopPropagation) {
                // 阻止事件继续传播
                break;
            }
        }
    }
    function getEventCallbackNameFromEventType(eventType) {
        return {
            click: ['onClickCapture', 'onClick']
        }[eventType];
    }
    /**
     * 收集沿途的事件方法
     * @param targetElement 实际触发事件的目标
     * @param container 根部容器
     * @param eventType 事件类型
     * @returns
     */
    function collectPaths(targetElement, container, eventType) {
        const paths = {
            capture: [],
            bubble: []
        };
        // 向上循环
        while (targetElement && targetElement !== container) {
            // 收集,拿到真实dom里面保存的props
            const elementProps = targetElement[elementPropsKey];
            // 如果存在
            if (elementProps) {
                // click => onClick onClickCapture
                // 根据时间类型拿到实际jsx中的事件回调函数名
                const callbackNameList = getEventCallbackNameFromEventType(eventType);
                // 如果存在
                if (callbackNameList) {
                    callbackNameList.forEach((callbackName, i) => {
                        // 从实际的props中拿到对应真正填写的函数对象的方法体
                        const eventCallback = elementProps[callbackName];
                        // 如果方法体存在，例如我在jsx中填写了 onClick={this.xxx}
                        if (eventCallback) {
                            // 放到对于的数组中
                            if (i === 0) {
                                // capture
                                paths.capture.unshift(eventCallback);
                            }
                            else {
                                paths.bubble.push(eventCallback);
                            }
                        }
                    });
                }
            }
            // 向上循环，知道根部容器
            targetElement = targetElement.parentNode;
        }
        return paths;
    }

    // 描述宿主环境方法的文件
    // 暂时先把props去掉
    const createInstance = (type, props) => {
        // TODO 处理props
        const element = document.createElement(type);
        updateFiberProps(element, props);
        return element;
    };
    const appendInitialChild = (parent, child) => {
        parent.appendChild(child);
    };
    const createTextInstance = (content) => {
        return document.createTextNode(content);
    };
    const appendChildToContainer = appendInitialChild;
    function commitUpdate(fiber) {
        switch (fiber.tag) {
            case HostText:
                const text = fiber.memoizedProps.content;
                return commitTextUpdate(fiber.stateNode, text);
            default:
                {
                    console.warn('未实现的Update类型', fiber);
                }
                break;
        }
    }
    function commitTextUpdate(textInstance, content) {
        textInstance.textContent = content;
    }
    function removeChild(child, container) {
        container.removeChild(child);
    }
    const scheduleMicroTask = typeof queueMicrotask === 'function'
        ? queueMicrotask
        : typeof Promise === 'function'
            ? (callback) => Promise.resolve(null).then(callback)
            : setTimeout;

    // Symbol是否存在
    const supportSymbol = typeof Symbol === 'function' && Symbol.for;
    const REACT_ELEMENT_TYPE = supportSymbol ? Symbol.for('react.element') : 0xeac7;
    const REACT_FRAGMENT_TYPE = supportSymbol ? Symbol.for('react.fragment') : 0xeacb;

    // 实现生成子节点以及标记Fibers的过程
    // shouldTrackEffects是否应该追踪副作用false代表不需要
    function ChildReconciler(shouldTrackEffects) {
        /**
         * 添加并标记要删除旧的子节点
         * @param returnFiber 父节点的FiberNode
         * @param childToDelete 子节点的FiberNode
         * @returns
         */
        function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackEffects) {
                // 如果不同追踪副作用的话直接return
                return;
            }
            const deletions = returnFiber.deletions;
            if (deletions === null) {
                // 将被移除的子节点
                returnFiber.deletions = [childToDelete];
                // 父节点中添加移除标记
                returnFiber.flags |= ChildDeletion;
            }
            else {
                returnFiber.deletions?.push(childToDelete);
            }
        }
        /**
         * 标记删除的方法
         * @param returnFiber 父节点
         * @param currentFirstChild 将被删除的子节点
         * @returns
         */
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
            // 是否追踪副作用
            if (!shouldTrackEffects) {
                return;
            }
            let childToDelete = currentFirstChild;
            // 循环移除兄弟节点
            while (childToDelete != null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
            }
        }
        // 通过ReactElementType生成新的FiberNode并建立父子的FiberNode的关系
        // 返回的是子FiberNode
        function reconcileSingleElement(returnFiber, currentFiber, element) {
            const key = element.key;
            // currentFiber也就是returnFiber的child子节点,如果是首次挂载的时候这个时候returnFiber由于还没有走到该方法下面的逻辑
            // 这意味着child还没有根据element生成并添加到child中，所以currentFiber === null,所以第一次加载的时候就不会复用FiberNode
            // 使得新返回出去的子节点的alternate为null
            while (currentFiber !== null) {
                // 如果旧的子节点FiberNode不为null，证明这个是update的情况
                if (currentFiber.key === key) {
                    // key相同
                    if (element.$$typeof === REACT_ELEMENT_TYPE) {
                        if (currentFiber.type === element.type) {
                            let props = element.props;
                            if (element.type === REACT_FRAGMENT_TYPE) {
                                props = element.props.children;
                            }
                            // type也相同,可以复用
                            const existing = useFiber(currentFiber, props);
                            existing.return = returnFiber;
                            // 当前节点可复用标记剩下的节点删除
                            deleteRemainingChildren(returnFiber, currentFiber.sibling);
                            return existing;
                        }
                        // type不同添加要删除的子节点并标记,并且要删掉所有旧的
                        // 这里因为是在调用这个方法之前就判断了typeof element参数=== 'object'所以新的element不会是多个的情况
                        deleteRemainingChildren(returnFiber, currentFiber);
                        break;
                    }
                    else {
                        // 如果ReactElementType不等于REACT_ELEMENT_TYPE类型就报错
                        {
                            console.warn('还未实现的react类型', element);
                            break;
                        }
                    }
                }
                else {
                    // 如果key不相同，我们就删掉旧的，那么在下面就会创建新的
                    // 添加要删除的子节点并标记
                    deleteChild(returnFiber, currentFiber);
                    currentFiber = currentFiber.sibling;
                }
            }
            // 根据element创建Fiber
            let fiber;
            if (element.type === REACT_FRAGMENT_TYPE) {
                fiber = createFiberFromFragment(element.props.children, key);
            }
            else {
                fiber = createFiberFromElement(element);
            }
            // 将创建的fiber父节点指向returnFiber
            fiber.return = returnFiber;
            return fiber;
        }
        function reconcileSingleTextNode(returnFiber, currentFiber, content) {
            while (currentFiber !== null) {
                // update
                if (currentFiber.tag === HostText) {
                    // 类型没变，可以复用
                    const existing = useFiber(currentFiber, { content });
                    existing.return = returnFiber;
                    deleteRemainingChildren(returnFiber, currentFiber.sibling);
                    return existing;
                }
                // 类型不一致需要删掉
                deleteChild(returnFiber, currentFiber);
                currentFiber = currentFiber.sibling;
            }
            const fiber = new FiberNode(HostText, { content }, null);
            fiber.return = returnFiber;
            return fiber;
        }
        // 添加插入的标记
        function placeSingleChild(fiber) {
            // shouldTrackEffects表示需要追踪副作用
            // fiber代表着子节点的FiberNode,fiber.alternate === null,表示子节点是首次加载，否则表示是经过复用的，就不需要添加插入标记
            if (shouldTrackEffects && fiber.alternate === null) {
                // 按位或操作，添加插入标记
                fiber.flags |= Placement;
            }
            return fiber;
        }
        function reconcileChildrenArray(returnFiber, currentFiberChild, newChild) {
            // 最后一个可复用fiber在current中的index
            let lastPlacedIndex = 0;
            // 创建的最后一个Fiber
            let lastNewFiber = null;
            // 创建的第一个Fiber
            let firstNewFiber = null;
            // 1.将current保存在map中
            const existingChildren = new Map();
            // currentFiberChild是旧的fiberNode他的结构是通过sibling这个来保存兄弟节点直接的关系，而newChild则是数组
            let current = currentFiberChild;
            // 遍历将FiberNode原本的链表形式保存到Map对象中
            while (current !== null) {
                // 如果存在key就有key最为键没有就用下标
                const keyToUse = current.key !== null ? current.key : current.index;
                existingChildren.set(keyToUse, current);
                current = current.sibling;
            }
            // 循环ReactElement数组
            for (let i = 0; i < newChild.length; i++) {
                // 2.遍历newChild，寻找是否可复用
                const after = newChild[i];
                // updateFromMap这个方法大致就是根据after.key 或者是下标i在existingChildren中是否有相同类型的，有的话复用，没有的话返回新的
                // 同时会删除existingChildren中可复用的key，这意味着在当前的for循环走完之后，剩下的就是将要被删除的旧的fiber
                const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
                // 如果newFiber返回null就中断,目前文本节点就会返回不相同就会返回null
                if (newFiber === null) {
                    continue;
                }
                // 3.标记移动还是插入
                // 给新节点中标记新的下标i
                newFiber.index = i;
                // 绑定父节点
                newFiber.return = returnFiber;
                if (lastNewFiber === null) {
                    // 第一次的时候因为只有一个新旧节点都是一样的
                    lastNewFiber = newFiber;
                    firstNewFiber = newFiber;
                }
                else {
                    // 当循环二次以上的时候lastNewFiber就是上一个节点标记为兄弟关系
                    lastNewFiber.sibling = newFiber;
                    // 将lastNewFiber指针指向新的节点
                    lastNewFiber = lastNewFiber.sibling;
                }
                // 判断是否追踪副作用，不追追踪就结束
                if (!shouldTrackEffects) {
                    continue;
                }
                // 获取新节点中的上一个节点,如果是复用节点那就current就会有值，否则就是mount
                const current = newFiber.alternate;
                if (current !== null) {
                    // 拿出上一次节点的下标
                    const oldIndex = current.index;
                    if (oldIndex < lastPlacedIndex) {
                        // 移动
                        newFiber.flags |= Placement;
                    }
                    else {
                        // 不移动
                        lastPlacedIndex = oldIndex;
                    }
                }
                else {
                    // mount,属于插入
                    newFiber.flags |= Placement;
                }
            }
            // 4.将map中剩下的标记为删除
            existingChildren.forEach((fiber) => {
                deleteChild(returnFiber, fiber);
            });
            return firstNewFiber;
        }
        /**
         * 从existingChildren的Map中判断是否存在可复用,不可复用则创建一个新的FiberNode返回同时删除existingChildren中可复用的的FiberNode
         * @param returnFiber
         * @param existingChildren
         * @param index
         * @param element 当结构为<ul><li>a</li><li>b</li>{arr}</ul>, element存在为数组的情况
         * @returns
         */
        function updateFromMap(returnFiber, existingChildren, index, element) {
            // 如果element中没有key就是index
            const keyToUse = element.key !== null ? element.key : index;
            // 从Map中找到原有的Fiber
            let before;
            // 如果是textNode
            if (typeof element === 'string' || typeof element === 'number') {
                before = existingChildren.get(index);
                // HostText
                if (before) {
                    // 如果fiber的类型是HostText证明是文本类型可以复用
                    if (before.tag === HostText) {
                        // 注意这里的delete是Map中的删除，从Map中删除这个信息，并不是添加删除的标记
                        existingChildren.delete(index);
                        // 返回复用的的fiber节点
                        return useFiber(before, { content: element + '' });
                    }
                }
            }
            // ReactElement
            if (typeof element === 'object' && element !== null) {
                // 处理element为数组的情况
                if (Array.isArray(element)) {
                    // 处理Fragment
                    /**
                     * element可能还是array 考虑如下，其中list是个array：
                     * <ul>
                     * 	<li></li>
                     * 	{list}
                     * </ul>
                     * 这种情况我们应该视element为Fragment
                     */
                    before = existingChildren.get(index);
                    // 通过updateFragment调用之后返回出去的就是Fragment类型的FiberNode节点
                    // 如果element是数组的情况下就会返回一个Fragment类型的FiberNode，在begin阶段中就会往下遍历最终执行到这个Fragment类型的节点
                    return updateFragment$1(returnFiber, before, element, index, existingChildren);
                }
                // 单一element节点
                before = existingChildren.get(keyToUse);
                // 处理element为单个节点的情况
                switch (element.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                        if (element.type === REACT_FRAGMENT_TYPE) {
                            return updateFragment$1(returnFiber, before, element, index, existingChildren);
                        }
                        // element是标签节点
                        if (before) {
                            // type相同
                            if (before.type === element.type) {
                                // 这里同样也是删除Map中的数据，不是添加删除标记
                                existingChildren.delete(keyToUse);
                                // 返回一个复用的值
                                return useFiber(before, element.props);
                            }
                        }
                        // 如果类型不相同或者是旧的节点不存在， 就不可以复用，需要创建一个新的
                        return createFiberFromElement(element);
                }
            }
            return null;
        }
        return function reconcileChildFibers(
        // 父节点的FiberNode
        returnFiber, 
        // 当前节点的子节点的FiberNode
        currentFiber, 
        // 子节点的ReactElement
        newChild) {
            // 判断下Fragment
            // 对于类似 <ul><><li/><li/></></ul> 这样内部直接使用<>作为Fragment的情况
            const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
                newChild !== null &&
                newChild.type === REACT_FRAGMENT_TYPE &&
                newChild.key === null;
            // 是否是Fragment
            if (isUnkeyedTopLevelFragment) {
                // 是的话往下取一层
                newChild = newChild?.props?.children;
            }
            // $$typeof除了文本节点不存在以外剩下的不管是组件还是普通节点或者是Fragment都为REACT_ELEMENT_TYPE
            if (typeof newChild === 'object' && newChild !== null) {
                switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                        // 根据newChild生成一个新的FiberNode并且指向returnFiber，如果是首次渲染的话会直接给flags加上Placement标记
                        // reconcileSingleElement方法返回的是currentFiber的子节点也就是currentFiber.child
                        // placeSingleChild这里如果有追踪副作用的情况下会添加插入的标记Placement(给currentFiber.child添加)
                        // 也就是说HostRoot的子节点在首次渲染的时候会添加Placement标记
                        return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                }
                // 多节点的情况 ul > 3li
                if (Array.isArray(newChild)) {
                    return reconcileChildrenArray(returnFiber, currentFiber, newChild);
                }
            }
            // HostText
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
            }
            // 兜底删除
            if (currentFiber !== null) {
                deleteRemainingChildren(returnFiber, currentFiber);
            }
            // 如果以上都没有
            {
                console.warn('未实现的reconcile类型', newChild);
            }
            return null;
        };
    }
    // 复用的方法
    function useFiber(fiber, pendingProps) {
        // 克隆一个fiber
        const clone = createWorkInProgress(fiber, pendingProps);
        // 索引赋值为0
        clone.index = 0;
        // 兄弟节点为null
        clone.sibling = null;
        return clone;
    }
    /**
     * 判断Fragment是否可复用，不可复用生成新的Fragment的FiberNode节点，并关联父级
     * @param returnFiber 父节点的FiberNode
     * @param current 旧得FiberNode首次加载为空
     * @param elements <ul><li>a</li><li>b</li>{arr}</ul>, element为数组的情况
     * @param key keyToUse存在key的情况下为key，否则为下标，当arr为数组的情况下，我们是将其看成为Fragment节点所以key为undefined
     * @param existingChildren 待处理的旧节点Map集合
     * @returns
     */
    function updateFragment$1(returnFiber, current, elements, key, existingChildren) {
        let fiber;
        // 上一个节点不存在，或者不为Fragment类型
        if (!current || current.tag !== Fragment) {
            // 创建一个Fragment类型的FiberNode节点
            fiber = createFiberFromFragment(elements, key);
        }
        else {
            // 复用节点
            existingChildren.delete(key);
            fiber = useFiber(current, elements);
        }
        fiber.return = returnFiber;
        return fiber;
    }
    // 更新
    const reconcileChildFibers = ChildReconciler(true);
    // 挂载
    const mountChildFibers = ChildReconciler(false);

    const internals = React__namespace.__SECRET_INTERNELS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

    // 对于effect hook, Passive代表[useEffect对应的effect]
    const Passive = 0b0001;
    // 如果不仅包含Passive还包含了HookHasEffect,代表了不仅是useEffect，而且本次更新还存在了副作用
    const HookHasEffect = 0b0001;

    const { currentDispatcher } = internals;
    // 当前正在render的FiberNode
    let currentlyRenderingFiber = null;
    // 当前正在处理的hook
    let workInProgressHook = null;
    let currentHook = null;
    let renderLane = NoLane;
    // 函数组件执行的方法
    function renderWithHooks(wip, lane) {
        // 赋值操作
        currentlyRenderingFiber = wip;
        // memoizedState这里是指向hook的链表
        wip.memoizedState = null;
        // 重置effect链表
        wip.updateQueue = null;
        // 接下来执行的时候我们需要创建这个链表
        renderLane = lane;
        const current = wip.alternate;
        if (current !== null) {
            // update
            currentDispatcher.current = HooksDispatcherOnUpdate;
        }
        else {
            // mount，将mount阶段的hook集合塞进去，这样在函数执行的时候就可以成功调用到hooks
            currentDispatcher.current = HooksDispatcherOnMount;
        }
        // 如果传入的是一个函数组件，那么FiberNode的type就是方法体
        const Component = wip.type;
        const props = wip.pendingProps;
        // 函数返回的就是children
        const children = Component(props);
        // 重置操作
        currentlyRenderingFiber = null;
        workInProgressHook = null;
        currentHook = null;
        renderLane = NoLane;
        return children;
    }
    // 挂载时的hooks集合
    const HooksDispatcherOnMount = {
        useState: mountState,
        useEffect: mountEffect
    };
    const HooksDispatcherOnUpdate = {
        useState: updateState,
        useEffect: updateEffect
    };
    function mountEffect(create, deps) {
        // 这个是函数组件第一个调用的时候生成的hooks链表，同时会返回当前的hook对象
        const hook = mountWorkInProgresHook();
        const nextDeps = deps === undefined ? null : deps;
        // 这就代表mount的时候需要处理副作用
        currentlyRenderingFiber.flags |= PassiveEffect;
        hook.memoizedState = pushEffect(Passive | PassiveEffect, create, undefined, nextDeps);
    }
    function updateEffect(create, deps) {
        // 这个是函数组件第一个调用的时候生成的hooks链表，同时会返回当前的hook对象
        const hook = updateWorkInProgresHook();
        const nextDeps = deps === undefined ? null : deps;
        let destroy;
        if (currentHook !== null) {
            const prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
                // 浅比较依赖
                const prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                    // 依赖没有变
                    hook.memoizedState = pushEffect(Passive, create, destroy, nextDeps);
                    return;
                }
            }
            // 钱比较后不相等
            currentlyRenderingFiber.flags |= PassiveEffect;
            hook.memoizedState = pushEffect(Passive | HookHasEffect, create, destroy, nextDeps);
        }
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null || nextDeps === null) {
            return false;
        }
        for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (Object.is(prevDeps[i], nextDeps[i])) {
                continue;
            }
            return false;
        }
        return true;
    }
    function pushEffect(hookFlags, create, destroy, deps) {
        const effect = {
            tag: hookFlags,
            create,
            destroy,
            deps,
            next: null
        };
        const fiber = currentlyRenderingFiber;
        const updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
            const updateQueue = createFCUpdateQueue();
            fiber.updateQueue = updateQueue;
            effect.next = effect;
            updateQueue.lastEffect = effect;
        }
        else {
            // 插入effect
            const lastEffect = updateQueue.lastEffect;
            if (lastEffect === null) {
                effect.next = effect;
                updateQueue.lastEffect = effect;
            }
            else {
                const firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                updateQueue.lastEffect = effect;
            }
        }
        return effect;
    }
    function createFCUpdateQueue() {
        const updateQueue = createUpdateQueue();
        updateQueue.lastEffect = null;
        return updateQueue;
    }
    /**
     * 组件更新的时候的useState
     * @returns
     */
    function updateState() {
        // 拿到组件上一次的hook信息
        const hook = updateWorkInProgresHook();
        // 实现updateState中[计算新的state的逻辑]
        const queue = hook.updateQueue;
        const pending = queue.shared.pending;
        // queue.shared.pending现在是链表结构，需要置空
        queue.shared.pending = null;
        if (pending !== null) {
            // 如果上一个组件有调用dispatch更改值的话，那么pending也就是传入的上一个调用dispatch的时候添加进得update
            // 在这里我们消费掉update得到最新的值
            const { memoizedState } = processUpdateQueue(hook.memoizedState, pending, renderLane);
            // 将最新的结果更新到hook中
            hook.memoizedState = memoizedState;
        }
        // 再将当前的新的hook结果返回出去
        return [hook.memoizedState, queue.dispatch];
    }
    function updateWorkInProgresHook() {
        // TODO render阶段触发的更新
        let nextCurrentHook;
        if (currentHook === null) {
            // 这是这个FC update时的第一个hook
            const current = currentlyRenderingFiber?.alternate;
            if (current !== null) {
                nextCurrentHook = current?.memoizedState;
            }
            else {
                nextCurrentHook = null;
            }
        }
        else {
            nextCurrentHook = currentHook.next;
        }
        if (nextCurrentHook === null) {
            // mount/update u1 u2 u3
            // update       u1 u2 u3 u4
            throw new Error(`组件${currentlyRenderingFiber?.type}本次执行时的Hook比上次执行时多`);
        }
        currentHook = nextCurrentHook;
        const newHook = {
            memoizedState: currentHook.memoizedState,
            updateQueue: currentHook.updateQueue,
            next: null
        };
        // 当前没有在操作的hook，表示这个阶段是第一次进来函数的时候执行的第一个hook
        if (workInProgressHook === null) {
            // 判断一下当前是否是在hooks的执行上下文中如果等于null则表示不是，那么就不是在函数组件中
            // mount时 第一个hook
            if (currentlyRenderingFiber === null) {
                throw new Error('请在函数组件内调用hook');
            }
            else {
                workInProgressHook = newHook;
                // 当前的FiberNode.memoizedState指向该hook链表，因为其余的hook都在第一个hook的next中，所以第一个创建的hooks其实就包含所有的hook
                currentlyRenderingFiber.memoizedState = workInProgressHook;
            }
        }
        else {
            // mount时 后续的hook
            // 将后续生成的hook指向上一个hooks的next
            workInProgressHook.next = newHook;
            // 将当前的指针指向新的hook，这样下次调用就可以继续生成新的hook被当前的next所指向
            workInProgressHook = newHook;
        }
        return workInProgressHook;
    }
    // initialState就是函数组件调用useState传入得到值
    function mountState(initialState) {
        // 这个是函数组件第一个调用的时候生成的hooks链表，同时会返回当前的hook对象
        const hook = mountWorkInProgresHook();
        // 处理useState传入的值
        let memoizedState;
        if (initialState instanceof Function) {
            memoizedState = initialState();
        }
        else {
            memoizedState = initialState;
        }
        // 给当前的hooks赋值一个updateQueue跟传入的值的处理结果memoizedState
        const queue = createUpdateQueue();
        hook.updateQueue = queue;
        hook.memoizedState = memoizedState;
        // 锁定参数,为了dispatch能脱离当前点额函数调用
        // 将当前点额函数组件的FiberNode=currentlyRenderingFiber传递给dispatch以及当前的queue
        // @ts-ignore
        const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        // 将dispatch保存起来(暂时没看到一定要保存起来的必要)
        queue.dispatch = dispatch;
        return [memoizedState, dispatch];
    }
    /**
     * 这个就是useState调用修改值的dispatch方法
     * @param fiber
     * @param updateQueue
     * @param action 传入的对象
     */
    function dispatchSetState(fiber, updateQueue, action) {
        // 返回SyncLane
        const lane = requestUpdateLane();
        // 创建一个update,将当前任务的优先级lane添加进去
        const update = createUpdate(action, lane);
        // 绑定update,enqueueUpdate方法支持多次添加会形成一个环状链表的结构,但更新多次调用的时候updateQueue会形成一个链表
        //
        enqueueUpdate(updateQueue, update);
        // 执行调度,会重新调用renderRoot
        scheduleUpdateOnFiber(fiber, lane);
    }
    function mountWorkInProgresHook() {
        const hook = {
            memoizedState: null,
            updateQueue: null,
            next: null
        };
        // 当前没有在操作的hook，表示这个阶段是第一次进来函数的时候执行的第一个hook
        if (workInProgressHook === null) {
            // 判断一下当前是否是在hooks的执行上下文中如果等于null则表示不是，那么就不是在函数组件中
            // mount时 第一个hook
            if (currentlyRenderingFiber === null) {
                throw new Error('请在函数组件内调用hook');
            }
            else {
                workInProgressHook = hook;
                // 当前的FiberNode.memoizedState指向该hook链表，因为其余的hook都在第一个hook的next中，所以第一个创建的hooks其实就包含所有的hook
                currentlyRenderingFiber.memoizedState = workInProgressHook;
            }
        }
        else {
            // mount时 后续的hook
            // 将后续生成的hook指向上一个hooks的next
            workInProgressHook.next = hook;
            // 将当前的指针指向新的hook，这样下次调用就可以继续生成新的hook被当前的next所指向
            workInProgressHook = hook;
        }
        return workInProgressHook;
    }

    // 递归中的递阶段
    // beginWork的工作流程
    // 1.计算状态的最新值
    // 2.创造子fiberNode
    const beginWork = (wip, renderLane) => {
        // 比较，返回子fiberNode
        switch (wip.tag) {
            case HostRoot:
                return updateHostRoot(wip, renderLane);
            case HostComponent:
                return updateHostComponent(wip);
            case HostText:
                return null;
            case FunctionComponent:
                return updateFunctionComponent(wip, renderLane);
            case Fragment:
                return updateFragment(wip);
            default:
                {
                    console.warn('beginWork未实现的类型');
                }
                break;
        }
        return null;
    };
    function updateFragment(wip) {
        // 在Fragment中pendingProps就是被包裹的子节点，在childFiber.ts中updateFragment方法中调用createFiberFromFragment产生的Fragment类型的节点
        const nextChildren = wip.pendingProps;
        // 拿到节点之后就会继续往下执行
        reconileChildren(wip, nextChildren);
        return wip.child;
    }
    function updateFunctionComponent(wip, renderLane) {
        // renderWithHooks方法就是执行函数组件wip的方法
        // 当执行完内部的函数方法之后，就会再次调用到useState,那么就会走到update生命周期的hook,会消费上一次dispatch传入的action,最终返回函数组件内部的返回的ReactElementType
        const nextChildren = renderWithHooks(wip, renderLane);
        reconileChildren(wip, nextChildren);
        return wip.child;
    }
    function updateHostRoot(wip, renderLane) {
        const baseState = wip.memoizedState;
        const updateQueue = wip.updateQueue;
        // 取出的pending就是Update对象
        // Update的对象里面包含action，action的值是传进来的ReactElementType对象
        const pending = updateQueue.shared.pending;
        // 清空原有对象中的pending
        updateQueue.shared.pending = null;
        // renderLane是本地消费的优先级，会循环updateQueue中的所有Update优先级相同的Update消费并更新baseState
        const { memoizedState } = processUpdateQueue(baseState, pending, renderLane);
        // 从目前上看这里是拿到了ReactElementType对象并且保存到memoizedState
        wip.memoizedState = memoizedState;
        // 这是更新后的ReactElementType
        const nextChildren = wip.memoizedState;
        // 比较子节点赋值回新的child
        reconileChildren(wip, nextChildren);
        // 返回子节点
        return wip.child;
    }
    function updateHostComponent(wip) {
        const nextProps = wip.pendingProps;
        const nextChildren = nextProps.children;
        reconileChildren(wip, nextChildren);
        return wip.child;
    }
    // 这个方法整体就是传入FiberNode以及当前子节点的ReactElementType
    // 然后比较FiberNode子节点与ReactElementType生成新的子节点FiberNode并添加上操作标记
    // 将FiberNode从新与当前父节点的FiberNode保存起来
    function reconileChildren(wip, children) {
        // 目前只有HostRootFiber是有alternate的
        const current = wip.alternate;
        if (current !== null) {
            // update
            // 比较子节点的current与子节点的ReactElementType
            // wip是当前的FiberNode父节点, current.child是上一个FiberNode子节点, children是当前的ReactElementType子节点
            // 目前的方法是根据children直接生成新的FiberNode,并将return指向wip,并加上flags标记
            wip.child = reconcileChildFibers(wip, current?.child, children);
        }
        else {
            // mount
            // 不追踪副作用
            wip.child = mountChildFibers(wip, null, children);
        }
    }

    let nextEffect = null;
    const commitMutationEffects = (finishedWork, root) => {
        nextEffect = finishedWork;
        while (nextEffect !== null) {
            // 向下遍历
            const child = nextEffect.child;
            // 这里这么做的原因，是找到最下级的需要操作的子节点，从当前子节点开始往上遍历之后再调用commitMutationEffectsOnFiber开始每个操作
            if ((nextEffect.subtreeFlags & (MutationMask | PassiveEffect)) !== NoFlags && child !== null) {
                // 若存在子节点需要更新的操作则向下继续遍历
                nextEffect = child;
            }
            else {
                // 证明要找的子节点不包含subtreeFlags
                // 向上遍历DFS
                while (nextEffect !== null) {
                    // 这里是处理节点的核心
                    commitMutationEffectsOnFiber(nextEffect, root);
                    // 兄弟节点
                    const sibling = nextEffect.sibling;
                    if (sibling !== null) {
                        // 如果存在兄弟节点，我们先处理兄弟节点，直到没有再向上找父级
                        nextEffect = sibling;
                        break;
                    }
                    nextEffect = nextEffect.return;
                }
            }
        }
    };
    // commit节点向上递归开始处理标记的方法
    const commitMutationEffectsOnFiber = (finishedWork, root) => {
        const flags = finishedWork.flags;
        if ((flags & Placement) !== NoFlags) {
            // 执行Placement这个是插入或者移动标记
            // 会将finishedWork插入到父级的上一层，如果父级是HostRoot则直接插入到容器里面
            commitPlacement(finishedWork);
            // 去除标记
            finishedWork.flags &= ~Placement;
        }
        if ((flags & Update) !== NoFlags) {
            // 执行Update操作
            commitUpdate(finishedWork);
            // 去除标记
            finishedWork.flags &= ~Update;
        }
        if ((flags & ChildDeletion) !== NoFlags) {
            // 删除操作
            const deletions = finishedWork.deletions;
            if (deletions !== null) {
                // deletions是一个数组
                deletions.forEach((childToDelete) => {
                    commitDeletion(childToDelete, root);
                });
            }
            // 去除标记
            finishedWork.flags &= ~ChildDeletion;
        }
        if ((flags & PassiveEffect) !== NoFlags) {
            // 收集回调
            commitPassiveEffect(finishedWork, root, 'update');
            // 移除标记
            finishedWork.flags &= ~PassiveEffect;
        }
    };
    function commitPassiveEffect(fiber, root, type) {
        // update unmount
        if (fiber.tag !== FunctionComponent ||
            (type === 'update' && fiber.flags & PassiveEffect) === NoFlags) {
            // 不是函数组件
            return;
        }
        const updateQueue = fiber.updateQueue;
        if (updateQueue !== null) {
            if (updateQueue.lastEffect === null && true) {
                console.error('当FC存在PassiveEffect flag时， 不应该不存在Effect');
            }
            root.pendingPassiveEffects[type].push(updateQueue.lastEffect);
        }
    }
    function commitHookEffectList(flags, lastEffect, callback) {
        let effect = lastEffect.next;
        do {
            if ((effect.tag & flags) === flags) {
                callback(effect);
            }
            effect = effect.next;
        } while (effect !== lastEffect.next);
    }
    function commitHookEffectListUnmount(flags, lastEffect) {
        commitHookEffectList(flags, lastEffect, (effect) => {
            const destroy = effect.destroy;
            if (typeof destroy === 'function') {
                destroy();
            }
            effect.tag &= ~HookHasEffect;
        });
    }
    function commitHookEffectListDestroy(flags, lastEffect) {
        commitHookEffectList(flags, lastEffect, (effect) => {
            const destroy = effect.destroy;
            if (typeof destroy === 'function') {
                destroy();
            }
        });
    }
    function commitHookEffectListCreate(flags, lastEffect) {
        commitHookEffectList(flags, lastEffect, (effect) => {
            const create = effect.create;
            if (typeof create === 'function') {
                effect.destroy = create();
            }
        });
    }
    /**
     * 当出现<><div>1</div><div>2</div></>这种情况的时候由于Fragment不是一个真实存在的节点所以不能用来执行removeDom的操作
     * 考虑删除Fragment后，子树的根Host节点可能存在多个
     * @param childrenToDelete
     * @param unmountFiber
     */
    function recordHostChildrenToDelete(childrenToDelete, unmountFiber) {
        // 1.找到第一个root host节点
        const lastOne = childrenToDelete[childrenToDelete.length - 1];
        if (!lastOne) {
            childrenToDelete.push(unmountFiber);
        }
        else {
            let node = lastOne.sibling;
            while (node !== null) {
                // 2.没找到一个 host 节点，判断下这个节点是不是 1 找到那个节点的兄弟节点
                // 是否与第一个被收集的节点是兄弟节点，是的话一并添加到childrenToDelete待删除
                if (unmountFiber === node) {
                    childrenToDelete.push(unmountFiber);
                }
                node = node.sibling;
            }
        }
    }
    function commitDeletion(childToDelete, root) {
        // 当前正在处理的FiberNode的根
        const rootChildrenToDelete = [];
        // 递归子树
        commitNestedUnmounts(childToDelete, (unmountFiber) => {
            // 当前方法会递归节点childToDelete下所有的子节点
            // 当出现 <div>
            //   <>
            //      <p>xxx</p>
            //      <p>yyy</p>
            //   </>
            // </div> 的时候由于<></>不是一个真实的节点所以不能添加到rootChildrenToDelete中
            // Fragment节点在当前switch中不会被处理,所以当childToDelete节点为Fragment的时候第一个被处理的节点是Fragment的非Fragment类型的子节点
            // 考虑删除Fragment后，子树的根Host节点可能存在多个,我们需要recordHostChildrenToDelete方法来收集第一个节点有可能存在多个节点的可能
            switch (unmountFiber.tag) {
                case HostComponent:
                    recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                    // TODO 解绑ref
                    return;
                case HostText:
                    recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                    return;
                case FunctionComponent:
                    // useEffect unmount的处理
                    commitPassiveEffect(unmountFiber, root, 'unmount');
                    return;
            }
        });
        // 移除rootHostComponent的DOM
        if (rootChildrenToDelete.length) {
            const hostParent = getHostParent(childToDelete);
            if (hostParent !== null) {
                rootChildrenToDelete.forEach((node) => {
                    removeChild(node.stateNode, hostParent);
                });
            }
        }
        childToDelete.return = null;
        childToDelete.child = null;
    }
    /**
     * 递归子树的方法
     * @param root 接收一个递归子树的根节点
     * @param onCommitUnmount 接收到的当前点递归的回调函数
     */
    function commitNestedUnmounts(root, onCommitUnmount) {
        let node = root;
        while (true) {
            onCommitUnmount(node);
            if (node.child !== null) {
                // 向下遍历
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === root) {
                // 终止条件
                return;
            }
            while (node.sibling === null) {
                if (node.return === null || node.return === root) {
                    return;
                }
                // 向上归
                node = node.return;
            }
            // 存在兄弟节点
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    // 这里是处理Placement标记的函数
    const commitPlacement = (finishedWork) => {
        {
            console.log('执行Placement操作', finishedWork);
        }
        // parent DOM
        // 这里是拿到当前的fiberNode的父节点的宿主环境Container
        const hostParent = getHostParent(finishedWork);
        // 找出当前节点的下一个没有添加Placement的兄弟节点，如果是最后一个就返回null
        const sibling = getHostSibling(finishedWork);
        // 接下来找到finishedWork对应的DOM并且将DOM append 到 parentDOM中
        if (hostParent !== null) {
            // 如果sibling为null调用appendChild插入到最后，如果不为null则插入到sibling之前
            insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
        }
    };
    function getHostSibling(fiber) {
        let node = fiber;
        findSibling: while (true) {
            // 这里是考虑到当前节点为组件的根节点的时候我们的相邻节点其实是组件的节点，所以要通过return取到上一级组件节点的相邻节点
            // <Component><div>当前为组件根节点相邻节点是当前fiberNode.return.siblint</div></Component><div></div>
            while (node.sibling === null) {
                // 当前节点若不存在兄弟节点则往上获取父级
                const parent = node.return;
                // 判断是否是组件
                if (parent === null || parent.tag === HostComponent || parent.tag === HostRoot) {
                    return null;
                }
                // 如果是组件继续往上找
                node = parent;
            }
            // 如果下一级兄弟节点存在，改变兄弟节点的父级指向,并将当前指正指向兄弟节点
            node.sibling.return = node.return;
            node = node.sibling;
            // 这里处理兄弟节点是组件的情况，如果是组件我们应该插入到组件的根节点
            // <div></div><Component><div>我是兄弟节点的组件插入到我的前面</div></Component>
            while (node.tag !== HostText && node.tag !== HostComponent) {
                // 向下遍历
                if ((node.flags & Placement) !== NoFlags) {
                    // 判断下组件的根节点时候是不移动类型，如果同样是有Placement标记的花我们应该跳出当前循环继续往下寻找
                    continue findSibling;
                }
                // 如果组件类型为null同样跳出
                if (node.child === null) {
                    continue findSibling;
                }
                else {
                    // 如果存在并且不为移动类型，则将指针指向当前节点继续再while循环中判断
                    node.child.return = node;
                    node = node.child;
                    // 这里为何不直接跳出是还有组件内继续还是组件的可能性
                }
            }
            // 这里找到下一个最近的不移动的节点
            // 13245 -> 21354
            // 那么需要移动的就是134
            // 1的下一个不移动节点是5，插入到5的前面变成32415
            // 3的下一个不移动节点是5，插入到前面变成24135  -----> 这里由于1跟3前面都是5所以先执行移动的必定再后执行移动的左边，因此符合新节点的顺序
            // 4的不存在下一个不移动节点，插入最后21354
            if ((node.flags & Placement) === NoFlags) {
                return node.stateNode;
            }
            // 如果当前节点是也是被打上Placement标记结束当前循环继续往下
        }
    }
    // 获得父级的宿主环境的节点
    function getHostParent(fiber) {
        // 执行一个向上遍历的过程
        let parent = fiber.return;
        while (parent) {
            const parentTag = parent.tag;
            // 那种环境下parentTag才对呀的是宿主环境下的父级节点呢
            // HostComponent HostRoot
            if (parentTag === HostComponent) {
                return parent.stateNode;
            }
            if (parentTag === HostRoot) {
                return parent.stateNode.container;
            }
            parent = parent.return;
            {
                console.warn('未找到host: parent');
            }
        }
        return null;
    }
    function insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, before) {
        // 向下遍历
        if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
            // 这里是将FiberNode的stateNode给插入到父级的DOM中，其实部分元素在completeWork已经插入,目前的话这里只有HostRoot的时候才会在HostRoot.child上面添加上插入标记
            // 只有在最后的当finishedWork = HostRootFiber的时候此时容器hostParent拿到的是挂载的节点#root这个时候就会挂载到界面上
            if (before) {
                insertChildToContainer(finishedWork.stateNode, hostParent, before);
            }
            else {
                console.log('后面插入', hostParent, finishedWork.stateNode);
                appendChildToContainer(hostParent, finishedWork.stateNode);
            }
            return;
        }
        // 到这里为组件类型，组件类型本身是不存在stateNode的所以我们需要取当前的FiberNode.child
        const child = finishedWork.child;
        if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, hostParent, before);
            let sibling = child.sibling;
            // 组件内有可能是多个根节点
            while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, hostParent, before);
                sibling = sibling.sibling;
            }
        }
    }
    // 在已有子节点之前插入新的子节点
    function insertChildToContainer(child, container, before) {
        // document的原生方法，将child插入到container内部的before节点之前
        container.insertBefore(child, before);
    }

    function markUpdate(fiber) {
        // 添加更新标记
        fiber.flags |= Update;
    }
    const completeWork = (wip) => {
        // 递归中的归
        const newProps = wip.pendingProps;
        // 这里那上一个值，新的值在begin阶段就已经更新好了
        const current = wip.alternate;
        switch (wip.tag) {
            case HostComponent:
                // current !== null证明当前节点是被复用过的
                if (current !== null && wip.stateNode) {
                    // update
                    // 1判断props是否变化
                    // 如果变了打上Update flag
                    // 这里暂时先直接改
                    updateFiberProps(wip.stateNode, newProps);
                }
                else {
                    // 1.构建真实DOM
                    const instance = createInstance(wip.type, newProps);
                    // 2.将DOM插入到DOM树中
                    appendAllChildren(instance, wip);
                    wip.stateNode = instance;
                }
                // flags冒泡
                bubbleProperties(wip);
                return null;
            case HostText:
                if (current !== null && wip.stateNode) {
                    // update
                    const oldText = current.memoizedProps.content;
                    const newText = newProps.content;
                    if (oldText !== newText) {
                        markUpdate(wip);
                    }
                }
                else {
                    // 1.构建DOM
                    const instance = createTextInstance(newProps.content);
                    wip.stateNode = instance;
                }
                // flags冒泡
                bubbleProperties(wip);
                return null;
            case HostRoot:
            case FunctionComponent:
            case Fragment:
                // flags冒泡
                bubbleProperties(wip);
                return null;
            default:
                {
                    console.warn('未处理的completeWork情况', wip);
                }
                break;
        }
    };
    // 接收一个parent以及要插入的FiberNode wip
    function appendAllChildren(parent, wip) {
        let node = wip.child;
        while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node?.stateNode);
            }
            else if (node.child !== null) {
                // 处理函数组件
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === wip) {
                return;
            }
            while (node.sibling === null) {
                if (node.return === null || node.return === wip) {
                    return;
                }
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    // 向上冒泡
    // completeWork是向上遍历的过程，所以拿到的节点一定是当前最顶部的节点，而咋子beginWork的过程中我们标记了flags
    // 我们为了不让更新时候再次产生整个树的深层递归，定义了一个subtreeFage标记了当前DOM树中子节点是否存在需要操作的标记
    function bubbleProperties(wip) {
        let subtreeFlags = NoFlags;
        let child = wip.child;
        while (child !== null) {
            subtreeFlags |= child.subtreeFlags;
            subtreeFlags |= child.flags;
            child.return = wip;
            child = child.sibling;
        }
        wip.subtreeFlags |= subtreeFlags;
    }

    let syncQueue = null;
    let isFlushingSyncQueue = false;
    function scheduleSyncCallback(callback) {
        if (syncQueue === null) {
            syncQueue = [callback];
        }
        else {
            syncQueue.push(callback);
        }
    }
    /**
     * 同步任务回调函数，开始调用当前函数的时候意味着syncQueue的所有调度任务已经添加完毕
     */
    function flushSyncCallbacks() {
        if (!isFlushingSyncQueue && syncQueue) {
            isFlushingSyncQueue = true;
            try {
                syncQueue.forEach((callback) => callback());
                // 消费完后清空
                syncQueue = null;
            }
            catch (e) {
                {
                    console.error('flushSyncCallbacks报错', e);
                }
            }
            finally {
                isFlushingSyncQueue = false;
            }
        }
    }

    // 这个是完整的工作循环的文件
    // 我们这里需要一个全局的指针来指向当前工作的FiberNode
    let workInProgress = null;
    let wipRootRenderLane = NoLane;
    let rootDoesHasPassiveEffects = false;
    // 初始化workInProgress
    function prepareFreshStack(root, lane) {
        // root.current也就是hostRootFiber
        // workInProgress：触发更新后，正在reconciler中计算的fiberNode树
        // createWorkInProgress的作用是传入一个hostRootFiber（也是FiberNode类型）然后返回一个新的hostRootFiber,并将旧的信息保存到hostRootFiber.alternate里面
        // 保存到workInProgress中
        workInProgress = createWorkInProgress(root.current, {});
        wipRootRenderLane = lane;
    }
    // 连接Container以及renderRoot的方法
    // 在Fiber调度Update
    function scheduleUpdateOnFiber(fiber, lane) {
        // TODO 调度功能
        // 拿到根节点fiberRootNode
        const root = markUpdateFromFiberToRoot(fiber);
        // 添加优先级（相同优先级更新不会引起变化）
        markRootUpdateed(root, lane);
        // 调用renderRoot开始跟新
        ensureRootIsScheduled(root);
    }
    function ensureRootIsScheduled(root) {
        // 从待处理的Lanes集合中获取优先级最高的Lane
        const updateLane = getHighesPriorityLane(root.pendingLanes);
        if (updateLane === NoLane) {
            // 结束更新
            return;
        }
        if (updateLane === SyncLane) {
            // 同步优先级 用微任务调度
            {
                console.log('在微任务中调度，优先级：', updateLane);
            }
            // scheduleSyncCallback是收集函数方法的函数想数组syncQueue添加一个performSyncWorkOnRoot
            // [performSyncWorkOnRoot, performSyncWorkOnRoot, performSyncWorkOnRoot]
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root, updateLane));
            // scheduleMicroTask是异步任务，flushSyncCallbacks是消费syncQueue的函数
            // 因此performSyncWorkOnRoot执行的次数也是跟当前函数执行的次数是一样的
            // 也就是说flushSyncCallbacks方法执行意味着performSyncWorkOnRoot也会执行
            scheduleMicroTask(flushSyncCallbacks);
        }
    }
    // 添加优先级
    function markRootUpdateed(root, lane) {
        // mergeLanes是按位或操作，合并集合
        root.pendingLanes = mergeLanes(root.pendingLanes, lane);
    }
    // 向上遍历拿到fiberRootNode
    function markUpdateFromFiberToRoot(fiber) {
        let node = fiber;
        let parent = node.return;
        while (parent !== null) {
            node = parent;
            parent = node.return;
        }
        if (node.tag === HostRoot) {
            return node.stateNode;
        }
        return null;
    }
    /**
     * 从跟节点开始更新
     * @param root 根节点fiberRootNode
     * @param lane 优先级（暂时还不清楚跟nextLane的区别）
     * @returns
     */
    function performSyncWorkOnRoot(root, lane) {
        // 获取下一个节点,这里开始执行调度挂载,当执行到commit阶段的时候会调用markRootFinished将当前最高的优先级去除掉
        // 去除掉之后这里再次获取就不会获取到重复的优先级没有的话就会中断后面的执行
        // 由于performSyncWorkOnRoot是异步所有在前面的时候，会执行所有的同步调度ensureRootIsScheduled那么同个优先级的update也都会被添加进去
        const nextLane = getHighesPriorityLane(root.pendingLanes);
        if (nextLane !== SyncLane) {
            // 其他比Synclane低的优先级
            // NoLane
            // 为了保险可以再调用一次
            ensureRootIsScheduled(root);
            return;
        }
        // 初始化
        prepareFreshStack(root, lane);
        // 执行递归流程
        do {
            try {
                workLoop();
                // 没有问题这里会直接跳出,到这个阶段的workInProgress已经遍历完，workInProgress会指向null
                break;
            }
            catch (e) {
                {
                    console.warn('workLoop发生错误');
                }
                // 改变指针
                workInProgress = null;
            }
        } while (true);
        // root.current.alternate就是workInProgress最开始指向的根节点
        // 这个时候的root.current.alternate已经是调度完成了，所以finishedWork会有最新的stateNode，也会有需要更新的flags标记
        const finishedWork = root.current.alternate;
        // 保存到finishedWork
        root.finishedWork = finishedWork;
        root.finishedLane = lane;
        wipRootRenderLane = NoLane;
        // 这里就可以根据fiberNode树 书中的flags
        commitRoot(root);
    }
    function commitRoot(root) {
        const finishedWork = root.finishedWork;
        if (finishedWork === null) {
            return;
        }
        {
            console.log('commit阶段开始', finishedWork);
        }
        const lane = root.finishedLane;
        if (lane === NoLane && true) {
            console.error('commit阶段finishedWork不应该是NoLane');
        }
        // 重置
        root.finishedWork = null;
        root.finishedLane = NoLane;
        // 移除优先级,当调用performSyncWorkOnRoot的时候,经过begin跟complete阶段最终会到commitRoot
        // 移除之后后续的performSyncWorkOnRoot这不会继续经过这3个阶段
        markRootFinished(root, lane);
        if ((finishedWork.flags & PassiveMask) !== NoFlags ||
            (finishedWork.subtreeFlags & PassiveMask) !== NoFlags) {
            if (!rootDoesHasPassiveEffects) {
                rootDoesHasPassiveEffects = true;
                // 调度副作用
                // scheduleCallback是调度的方法，NormalPriority这个是优先级，这里可以理解为是setTimeOut方法
                scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, () => {
                    // 执行副作用
                    flushPassiveEffects(root.pendingPassiveEffects);
                    return;
                });
            }
        }
        // 判断是否存在3个子阶段需要执行得到操作
        // 需要判断root本身的flags以及root的subtreeFlags
        // 这里是按位与操作subtreeHasEffect !== NoFlags标识存在子节点需要更新操作
        const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
        // rootHasEffect标识根节点存在需要更新的操作
        const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
        if (subtreeHasEffect || rootHasEffect) {
            // beforeMutation
            // mutation Placement
            commitMutationEffects(finishedWork, root);
            root.current = finishedWork;
            // layout
        }
        else {
            root.current = finishedWork;
        }
        rootDoesHasPassiveEffects = false;
        ensureRootIsScheduled(root);
    }
    function flushPassiveEffects(pendingPassiveEffects) {
        pendingPassiveEffects.unmount.forEach((effect) => {
            commitHookEffectListUnmount(Passive, effect);
        });
        pendingPassiveEffects.unmount = [];
        pendingPassiveEffects.update.forEach((effect) => {
            commitHookEffectListDestroy(Passive | HookHasEffect, effect);
        });
        pendingPassiveEffects.update.forEach((effect) => {
            commitHookEffectListCreate(Passive | HookHasEffect, effect);
        });
        pendingPassiveEffects.update = [];
        flushSyncCallbacks();
    }
    function workLoop() {
        // 只要指针不等于null就能一直循环下去,这里也就是递归中的递
        // 但completeUnitOfWork中循环到最上层的时候workInProgress则为null就会中断这一层方法内的while循环
        while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
        }
    }
    function performUnitOfWork(fiber) {
        // beginWork会拿到下一层得到子FiberNode
        const next = beginWork(fiber, wipRootRenderLane);
        // 更新Props的值，memoizedProps这个值其实就是对于的ReactElement的Props，里面有后续节点的信息
        fiber.memoizedProps = fiber.pendingProps;
        // 判断是否有下一层的FiberNode
        if (next === null) {
            // 不存在调用归
            completeUnitOfWork(fiber);
        }
        else {
            // 存在则指针指向下一层
            workInProgress = next;
        }
    }
    function completeUnitOfWork(fiber) {
        let node = fiber;
        do {
            // 执行递归中的归
            completeWork(node);
            // 拿到兄弟节点
            const sibling = node.sibling;
            if (sibling) {
                // 如果兄弟节点存在则指针指向兄弟节点
                workInProgress = sibling;
                return;
            }
            // 如果兄弟节点不存在则拿父级节点
            node = node.return;
            // 改变指针指向父级
            workInProgress = node;
        } while (node !== null);
    }

    // 实现mount时调用的api
    function createContainer(container) {
        const hostRootFiber = new FiberNode(HostRoot, {}, null);
        const root = new fiberRootNode(container, hostRootFiber);
        hostRootFiber.updateQueue = createUpdateQueue();
        return root;
    }
    // 执行render方法后内部调用的api
    function updateContainer(element, root) {
        const hostRootFiber = root.current;
        // 创建一个优先级
        const lane = requestUpdateLane();
        // 创建一个新的额Update
        // element也就是render传进来的ReactElementType
        const update = createUpdate(element, lane);
        // UpdateQueue是保存Update的数据结构
        // enqueueUpdate是将Update保存进UpdateQueue
        // 这里会将{ action: ReactElementType }结构数据保存金hostRootFiber.updateQueue.shared.padding里面
        enqueueUpdate(hostRootFiber.updateQueue, update);
        // 然后执行调度
        scheduleUpdateOnFiber(hostRootFiber, lane);
        return element;
    }

    // ReactDOM.createRoot(root).render(<APP/>)
    function createRoot(container) {
        // 创建传入dom节点创建fiberRootNode
        const root = createContainer(container);
        return {
            render(element) {
                initEvent(container, 'click');
                return updateContainer(element, root);
            }
        };
    }

    var ReactDOM = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createRoot: createRoot
    });

    return ReactDOM;

}));
